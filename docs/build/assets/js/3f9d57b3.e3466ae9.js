"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[618],{5688:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"recipes/multiple-signals","title":"Returning Multiple Signals","description":"Sometimes a neuron needs to emit multiple signals in response to a single input. CNStra supports returning arrays of signals from neuron responses.","source":"@site/recipes/multiple-signals.md","sourceDirName":"recipes","slug":"/recipes/multiple-signals","permalink":"/docs/recipes/multiple-signals","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/recipes/multiple-signals.md","tags":[],"version":"current","lastUpdatedAt":1760122051000,"frontMatter":{"id":"multiple-signals","title":"Returning Multiple Signals","sidebar_label":"Multiple Signals","slug":"/recipes/multiple-signals"},"sidebar":"docs","previous":{"title":"Error Handling","permalink":"/docs/recipes/error-handling"},"next":{"title":"Response listeners","permalink":"/docs/recipes/response-listeners"}}');var s=a(4848),r=a(8453);const i={id:"multiple-signals",title:"Returning Multiple Signals",sidebar_label:"Multiple Signals",slug:"/recipes/multiple-signals"},l=void 0,o={},c=[{value:"Basic Array Return",id:"basic-array-return",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Fan-out Pattern",id:"fan-out-pattern",level:3},{value:"Dynamic Signal Generation",id:"dynamic-signal-generation",level:3},{value:"Conditional Multiple Signals",id:"conditional-multiple-signals",level:3},{value:"Async Array Return",id:"async-array-return",level:2},{value:"Empty Arrays",id:"empty-arrays",level:2},{value:"Multiple Initial Signals",id:"multiple-initial-signals",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"Sometimes a neuron needs to emit multiple signals in response to a single input. CNStra supports returning arrays of signals from neuron responses."}),"\n",(0,s.jsx)(e.h2,{id:"basic-array-return",children:"Basic Array Return"}),"\n",(0,s.jsx)(e.p,{children:"A neuron can return an array of signals instead of a single signal:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { CNS, collateral, neuron } from '@cnstra/core';\n\nconst input = collateral<{ value: number }>('input');\nconst output1 = collateral<{ result: string }>('output1');\nconst output2 = collateral<{ result: string }>('output2');\n\nconst splitter = neuron('splitter', { output1, output2 }).dendrite({\n  collateral: input,\n  response: (payload, axon) => {\n    // Return an array of signals\n    return [\n      axon.output1.createSignal({ result: `First: ${payload.value}` }),\n      axon.output2.createSignal({ result: `Second: ${payload.value}` }),\n    ];\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsx)(e.h3,{id:"fan-out-pattern",children:"Fan-out Pattern"}),"\n",(0,s.jsx)(e.p,{children:"Split a single input into multiple parallel processing paths:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const processPayment = collateral<{ orderId: string }>('processPayment');\nconst updateInventory = collateral<{ orderId: string }>('updateInventory');\nconst notifyUser = collateral<{ orderId: string }>('notifyUser');\nconst logTransaction = collateral<{ orderId: string }>('logTransaction');\n\nconst orderProcessor = neuron('orderProcessor', {\n  updateInventory,\n  notifyUser,\n  logTransaction,\n}).dendrite({\n  collateral: processPayment,\n  response: (payload, axon) => {\n    // Process payment and trigger multiple downstream actions\n    return [\n      axon.updateInventory.createSignal({ orderId: payload.orderId }),\n      axon.notifyUser.createSignal({ orderId: payload.orderId }),\n      axon.logTransaction.createSignal({ orderId: payload.orderId }),\n    ];\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"dynamic-signal-generation",children:"Dynamic Signal Generation"}),"\n",(0,s.jsx)(e.p,{children:"Generate a variable number of signals based on input:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const batchInput = collateral<{ items: string[] }>('batchInput');\nconst itemOutput = collateral<{ item: string; index: number }>('itemOutput');\n\nconst batchProcessor = neuron('batchProcessor', { itemOutput }).dendrite({\n  collateral: batchInput,\n  response: (payload, axon) => {\n    // Create a signal for each item\n    return payload.items.map((item, index) =>\n      axon.itemOutput.createSignal({ item, index })\n    );\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"conditional-multiple-signals",children:"Conditional Multiple Signals"}),"\n",(0,s.jsx)(e.p,{children:"Return different numbers of signals based on conditions:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const validation = collateral<{ data: any }>('validation');\nconst success = collateral<{ validated: any }>('success');\nconst error = collateral<{ error: string }>('error');\nconst audit = collateral<{ action: string }>('audit');\n\nconst validator = neuron('validator', { success, error, audit }).dendrite({\n  collateral: validation,\n  response: (payload, axon) => {\n    const signals = [];\n    \n    if (isValid(payload.data)) {\n      signals.push(axon.success.createSignal({ validated: payload.data }));\n    } else {\n      signals.push(axon.error.createSignal({ error: 'Validation failed' }));\n    }\n    \n    // Always log to audit\n    signals.push(axon.audit.createSignal({ action: 'validation_attempt' }));\n    \n    return signals;\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"async-array-return",children:"Async Array Return"}),"\n",(0,s.jsx)(e.p,{children:"Arrays of signals work seamlessly with async functions:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const dataFetch = collateral<{ ids: string[] }>('dataFetch');\nconst dataReady = collateral<{ id: string; data: any }>('dataReady');\n\nconst fetcher = neuron('fetcher', { dataReady }).dendrite({\n  collateral: dataFetch,\n  response: async (payload, axon) => {\n    // Fetch all data asynchronously\n    const results = await Promise.all(\n      payload.ids.map(id => fetchData(id))\n    );\n    \n    // Return array of signals\n    return results.map((data, i) =>\n      axon.dataReady.createSignal({ id: payload.ids[i], data })\n    );\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"empty-arrays",children:"Empty Arrays"}),"\n",(0,s.jsx)(e.p,{children:"Returning an empty array is valid and will not propagate any signals:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const filter = neuron('filter', { output }).dendrite({\n  collateral: input,\n  response: (payload, axon) => {\n    if (!shouldProcess(payload)) {\n      return []; // No signals emitted\n    }\n    return [axon.output.createSignal(payload)];\n  },\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"multiple-initial-signals",children:"Multiple Initial Signals"}),"\n",(0,s.jsx)(e.p,{children:"You can also start a stimulation with multiple signals:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const cns = new CNS([/* neurons */]);\n\n// Stimulate with an array of signals\ncns.stimulate([\n  input.createSignal({ value: 1 }),\n  input.createSignal({ value: 2 }),\n  input.createSignal({ value: 3 }),\n]);\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use for genuine fan-out"}),": Return arrays when you truly need parallel processing, not just for convenience"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consider ordering"}),": Signals in the array are processed in order, but may execute concurrently based on queue settings"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Empty arrays are fine"}),": Don't hesitate to return an empty array when appropriate"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mix with single signals"}),": You can mix neurons that return single signals with those that return arrays"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Type safety"}),": TypeScript will enforce correct signal types in arrays"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Each signal in the array triggers its own set of subscribers"}),"\n",(0,s.jsx)(e.li,{children:"If you have many signals, consider using concurrency limits"}),"\n",(0,s.jsx)(e.li,{children:"Arrays are processed immediately; signals are not batched"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>i,x:()=>l});var t=a(6540);const s={},r=t.createContext(s);function i(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);