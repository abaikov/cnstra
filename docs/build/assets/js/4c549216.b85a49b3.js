"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[843],{2005:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core/api","title":"CNStra API Reference - Neurons, Signals, Collaterals, Context","description":"Complete CNStra API reference. Learn neuron, collateral, signal, dendrite, axon, context, stimulation APIs. Type-safe orchestration primitives for JavaScript/TypeScript state machines.","source":"@site/core/api.md","sourceDirName":"core","slug":"/core/api","permalink":"/docs/core/api","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/core/api.md","tags":[],"version":"current","lastUpdatedAt":1760139021000,"frontMatter":{"id":"api","title":"CNStra API Reference - Neurons, Signals, Collaterals, Context","sidebar_label":"API","slug":"/core/api","description":"Complete CNStra API reference. Learn neuron, collateral, signal, dendrite, axon, context, stimulation APIs. Type-safe orchestration primitives for JavaScript/TypeScript state machines.","keywords":["API reference","API documentation","neuron API","signal API","collateral API","dendrite API","axon API","context API","stimulation API","TypeScript API","type-safe API","function reference","method reference","interface reference"]},"sidebar":"docs","next":{"title":"Overview","permalink":"/docs/core/overview"}}');var s=r(4848),o=r(8453);const i={id:"api",title:"CNStra API Reference - Neurons, Signals, Collaterals, Context",sidebar_label:"API",slug:"/core/api",description:"Complete CNStra API reference. Learn neuron, collateral, signal, dendrite, axon, context, stimulation APIs. Type-safe orchestration primitives for JavaScript/TypeScript state machines.",keywords:["API reference","API documentation","neuron API","signal API","collateral API","dendrite API","axon API","context API","stimulation API","TypeScript API","type-safe API","function reference","method reference","interface reference"]},l=void 0,a={},c=[{value:"<code>collateral&lt;T&gt;(id: string)</code>",id:"collateraltid-string",level:3},{value:"<code>neuron(id: string, axon: Axon)</code>",id:"neuronid-string-axon-axon",level:3},{value:"Signal ownership",id:"signal-ownership",level:3},{value:"<code>neuron.dendrite({...})</code>",id:"neurondendrite",level:3},{value:"<code>neuron.bind(axon, map)</code>",id:"neuronbindaxon-map",level:3},{value:"<code>neuron.setConcurrency(n: number | undefined)</code>",id:"neuronsetconcurrencyn-number--undefined",level:3},{value:"<code>CNS</code>",id:"cns",level:3},{value:"<code>cns.stimulate(signal, options?)</code>",id:"cnsstimulatesignal-options",level:3},{value:"Single entry point",id:"single-entry-point",level:4},{value:"Stimulation options",id:"stimulation-options",level:4},{value:"Response shape (for listeners)",id:"response-shape-for-listeners",level:4},{value:"Global response listeners (middleware\u2011style)",id:"global-response-listeners-middlewarestyle",level:3}];function d(e){const n={admonition:"admonition",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"collateraltid-string",children:(0,s.jsx)(n.code,{children:"collateral<T>(id: string)"})}),"\n",(0,s.jsx)(n.p,{children:"Create a typed output channel."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const userEvent = collateral<{ userId: string }>('user:event');\nconst simpleEvent = collateral('simple:event');\n"})}),"\n",(0,s.jsx)(n.h3,{id:"neuronid-string-axon-axon",children:(0,s.jsx)(n.code,{children:"neuron(id: string, axon: Axon)"})}),"\n",(0,s.jsx)(n.p,{children:"Create a neuron with the given axon."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const myNeuron = neuron('my-neuron', { output: myCollateral });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"signal-ownership",children:"Signal ownership"}),"\n",(0,s.jsx)(n.admonition,{title:"Signal ownership",type:"warning",children:(0,s.jsx)(n.p,{children:"A neuron may emit only collaterals declared in its own axon. It must not emit another neuron's collaterals. Cross-neuron orchestration is done by having a controller own request collaterals and letting each domain neuron emit its own responses."})}),"\n",(0,s.jsx)(n.p,{children:"Incorrect (emits someone else's collateral):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// DON'T: myNeuron emits otherAxon.some\nreturn otherAxon.some.createSignal(result);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Correct (controller-owned request, domain emits its own):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const controller = neuron('controller', { requestA });\nconst serviceA = neuron('serviceA', { doneA })\n  .dendrite({ collateral: requestA, response: (_, axon) => axon.doneA.createSignal(...) });\n// controller emits requestA; serviceA emits doneA\n"})}),"\n",(0,s.jsx)(n.h3,{id:"neurondendrite",children:(0,s.jsx)(n.code,{children:"neuron.dendrite({...})"})}),"\n",(0,s.jsx)(n.p,{children:"Add a dendrite bound to a collateral."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"myNeuron.dendrite({\n  collateral: inputCollateral,\n  response: async (payload, axon, ctx) => {\n    if (ctx.abortSignal?.aborted) return;\n    return axon.output.createSignal(result);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"neuronbindaxon-map",children:(0,s.jsx)(n.code,{children:"neuron.bind(axon, map)"})}),"\n",(0,s.jsx)(n.p,{children:"Exhaustive bind to every collateral of another neuron's axon (compile-time safety)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"withCtx().neuron('order-mailer', {})\n  .bind(order, {\n    created: (payload) => { /* ... */ },\n    updated: (payload) => { /* ... */ },\n    cancelled: (payload) => { /* ... */ },\n  });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"neuronsetconcurrencyn-number--undefined",children:(0,s.jsx)(n.code,{children:"neuron.setConcurrency(n: number | undefined)"})}),"\n",(0,s.jsx)(n.p,{children:"Set per-neuron global concurrency limit (shared across all parallel stimulations)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const worker = neuron('worker', { out })\n  .setConcurrency(2) // max 2 parallel executions across all runs\n  .dendrite({ collateral: task, response: async (p, axon) => { /* ... */ } });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This limits how many concurrent executions of this neuron's dendrites can run at the same time, even across different ",(0,s.jsx)(n.code,{children:"stimulate()"})," calls. Useful for rate-limiting external APIs or heavy I/O operations."]}),"\n",(0,s.jsx)(n.h3,{id:"cns",children:(0,s.jsx)(n.code,{children:"CNS"})}),"\n",(0,s.jsxs)(n.p,{children:["Main orchestrator. ",(0,s.jsx)(n.code,{children:"new CNS(neurons, options?)"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const unsubscribe = cns.addResponseListener(r => { /* ... */ });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cnsstimulatesignal-options",children:(0,s.jsx)(n.code,{children:"cns.stimulate(signal, options?)"})}),"\n",(0,s.jsx)(n.p,{children:"Run a stimulation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await cns.stimulate(userCreated.createSignal({ id: '123', name: 'John' }));\n"})}),"\n",(0,s.jsx)(n.h4,{id:"single-entry-point",children:"Single entry point"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"stimulate(...)"})," is the only entry point that begins execution. Nothing runs until you explicitly stimulate a signal. This is the \u201cinverted\u201d part of IERG: you start the run and each dendrite returns the explicit continuation."]}),"\n",(0,s.jsx)(n.h4,{id:"stimulation-options",children:"Stimulation options"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await cns.stimulate(signal, {\n  onResponse: (r) => { /* per-stimulation hook */ },\n  abortSignal,                 // Abort the whole run cooperatively\n  concurrency: 4,              // Per-stimulation parallelism\n  maxNeuronHops:  undefined,   // Disabled by default; set to cap traversal length\n  allowName: (neuronName) => true, // Filter allowed neurons by name\n  stimulationId: 'run-123',    // Optional id for tracing\n  ctx,                         // Pre-supplied context store\n  createContextStore: () => myStore(), // Custom context store factory\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"response-shape-for-listeners",children:"Response shape (for listeners)"}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"onResponse"})," and global listeners receive the same object:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  inputSignal?: TCNSSignal;    // when a signal is ingested\n  outputSignal?: TCNSSignal;   // when a dendrite returns a continuation\n  ctx: ICNSStimulationContextStore;\n  queueLength: number;         // current work queue size\n  error?: Error;               // when a dendrite throws\n  hops?: number;               // present if maxNeuronHops is set\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"global-response-listeners-middlewarestyle",children:"Global response listeners (middleware\u2011style)"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"addResponseListener"})," to attach cross\u2011cutting concerns (logging, metrics, tracing) that run for every stimulation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const off = cns.addResponseListener((r) => {\n  if (r.error) {\n    metrics.count('error', 1);\n    return;\n  }\n  if (r.outputSignal) {\n    trace.log('out', r.outputSignal.collateralName);\n  } else if (r.inputSignal) {\n    trace.log('in', r.inputSignal.collateralName);\n  }\n});\n\n// later\noff();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Local ",(0,s.jsx)(n.code,{children:"onResponse"})," (per stimulation) runs as well as global listeners; both can be ",(0,s.jsx)(n.code,{children:"async"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["All listeners run in parallel per response; errors from any listener reject the ",(0,s.jsx)(n.code,{children:"stimulate(...)"})," Promise."]}),"\n",(0,s.jsx)(n.li,{children:"If all listeners are synchronous, no extra async deferrals are introduced."}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"allowName"}),"/",(0,s.jsx)(n.code,{children:"maxNeuronHops"})," to constrain traversal if needed."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(6540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);