"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[979],{6626:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"advanced/custom-context-store","title":"Custom Context Store","description":"Implement a custom context store for persistence, distributed systems, or specialized storage backends.","source":"@site/advanced/custom-context-store.md","sourceDirName":"advanced","slug":"/advanced/custom-context-store","permalink":"/docs/advanced/custom-context-store","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/advanced/custom-context-store.md","tags":[],"version":"current","lastUpdatedAt":1759841036000,"frontMatter":{"id":"custom-context-store","title":"Custom Context Store","sidebar_label":"Custom Context Store","slug":"/advanced/custom-context-store"},"sidebar":"docs","previous":{"title":"RabbitMQ","permalink":"/docs/integrations/rabbitmq"},"next":{"title":"Performance","permalink":"/docs/advanced/performance"}}');var r=n(4848),o=n(8453);const i={id:"custom-context-store",title:"Custom Context Store",sidebar_label:"Custom Context Store",slug:"/advanced/custom-context-store"},a=void 0,c={},d=[{value:"Interface",id:"interface",level:2},{value:"Redis-backed context store",id:"redis-backed-context-store",level:2},{value:"Database-backed context store",id:"database-backed-context-store",level:2},{value:"OIMDB-backed context store",id:"oimdb-backed-context-store",level:2},{value:"Reusing context for recovery",id:"reusing-context-for-recovery",level:2},{value:"Tips",id:"tips",level:2}];function l(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Implement a custom context store for persistence, distributed systems, or specialized storage backends."}),"\n",(0,r.jsx)(t.h2,{id:"interface",children:"Interface"}),"\n",(0,r.jsxs)(t.p,{children:["Context stores implement ",(0,r.jsx)(t.code,{children:"ICNSStimulationContextStore"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface ICNSStimulationContextStore {\n  get<T>(): T | undefined;\n  set<T>(value: T): void;\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"The default implementation is an in-memory store. For long-lived sagas or distributed systems, you can provide a persistent or shared store."}),"\n",(0,r.jsx)(t.h2,{id:"redis-backed-context-store",children:"Redis-backed context store"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { ICNSStimulationContextStore } from '@cnstra/core';\nimport { RedisClient } from 'redis';\n\nclass RedisContextStore implements ICNSStimulationContextStore {\n  constructor(\n    private client: RedisClient,\n    private sessionId: string\n  ) {}\n\n  get<T>(): T | undefined {\n    const raw = this.client.getSync(`cnstra:ctx:${this.sessionId}`);\n    return raw ? JSON.parse(raw) : undefined;\n  }\n\n  set<T>(value: T): void {\n    this.client.setSync(\n      `cnstra:ctx:${this.sessionId}`,\n      JSON.stringify(value),\n      'EX',\n      3600 // 1 hour TTL\n    );\n  }\n}\n\n// Use in stimulation\nawait cns.stimulate(signal, {\n  createContextStore: () => new RedisContextStore(redisClient, 'session-123')\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"database-backed-context-store",children:"Database-backed context store"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class DBContextStore implements ICNSStimulationContextStore {\n  constructor(\n    private db: DatabaseClient,\n    private runId: string\n  ) {}\n\n  get<T>(): T | undefined {\n    const row = this.db.query(\n      'SELECT data FROM context_store WHERE run_id = ?',\n      [this.runId]\n    );\n    return row ? JSON.parse(row.data) : undefined;\n  }\n\n  set<T>(value: T): void {\n    this.db.execute(\n      'INSERT INTO context_store (run_id, data) VALUES (?, ?) ON CONFLICT(run_id) DO UPDATE SET data = ?',\n      [this.runId, JSON.stringify(value), JSON.stringify(value)]\n    );\n  }\n}\n\nawait cns.stimulate(signal, {\n  createContextStore: () => new DBContextStore(db, 'run-456')\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"oimdb-backed-context-store",children:"OIMDB-backed context store"}),"\n",(0,r.jsx)(t.p,{children:"For reactive frontend state:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { db } from './oimdb-instance';\n\nclass OIMDBContextStore implements ICNSStimulationContextStore {\n  constructor(private runId: string) {}\n\n  get<T>(): T | undefined {\n    const record = db.context.selectByPrimaryKey({ runId: this.runId });\n    return record?.data as T | undefined;\n  }\n\n  set<T>(value: T): void {\n    db.context.upsertOne({ runId: this.runId, data: value });\n  }\n}\n\nawait cns.stimulate(signal, {\n  createContextStore: () => new OIMDBContextStore('run-789')\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"reusing-context-for-recovery",children:"Reusing context for recovery"}),"\n",(0,r.jsx)(t.p,{children:"When an error occurs, save the context store and retry:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"let savedContext: ICNSStimulationContextStore | undefined;\n\nawait cns.stimulate(signal, {\n  onResponse: (r) => {\n    if (r.error) {\n      savedContext = r.contextStore; // capture for retry\n    }\n  }\n});\n\n// Retry with same context\nif (savedContext) {\n  await cns.stimulate(retrySignal, { ctx: savedContext });\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"tips",children:"Tips"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Serialization"}),": Store only JSON-serializable data (no functions, Dates, etc.) unless using a custom serializer."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"TTL"}),": For distributed stores (Redis, DB), set TTL or cleanup policies to avoid unbounded growth."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance"}),": Persistent stores add I/O overhead; use in-memory stores for high-throughput short-lived flows."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Consistency"}),": In distributed systems, ensure your store supports read-your-own-writes semantics if neurons might run on different nodes."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);