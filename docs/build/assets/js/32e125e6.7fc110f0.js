"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[48],{2482:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"frontend/oimdb","title":"React State Management with CNStra & OIMDB - Redux Alternative","description":"Learn how CNStra + OIMDB provides deterministic React state management. A performant alternative to Redux, MobX, Zustand. Type-safe, derived state, reactive updates, SOLID/SRP by design. Perfect for complex React applications.","source":"@site/frontend/oimdb.md","sourceDirName":"frontend","slug":"/frontend/oimdb","permalink":"/docs/frontend/oimdb","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/frontend/oimdb.md","tags":[],"version":"current","lastUpdatedAt":1759841036000,"frontMatter":{"id":"oimdb","title":"React State Management with CNStra & OIMDB - Redux Alternative","sidebar_label":"CNStra & OIMDB","slug":"/frontend/oimdb","description":"Learn how CNStra + OIMDB provides deterministic React state management. A performant alternative to Redux, MobX, Zustand. Type-safe, derived state, reactive updates, SOLID/SRP by design. Perfect for complex React applications.","keywords":["React state management","Redux alternative","MobX alternative","Zustand alternative","Recoil alternative","Jotai alternative","React hooks","derived state","reactive state","OIMDB","in-memory database","frontend orchestration","React best practices","type-safe React state","deterministic React","performance optimization","state synchronization","React state machine"]},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/docs/concepts/intro"},"next":{"title":"React Patterns","permalink":"/docs/frontend/react-patterns"}}');var a=t(4848),o=t(8453);const s={id:"oimdb",title:"React State Management with CNStra & OIMDB - Redux Alternative",sidebar_label:"CNStra & OIMDB",slug:"/frontend/oimdb",description:"Learn how CNStra + OIMDB provides deterministic React state management. A performant alternative to Redux, MobX, Zustand. Type-safe, derived state, reactive updates, SOLID/SRP by design. Perfect for complex React applications.",keywords:["React state management","Redux alternative","MobX alternative","Zustand alternative","Recoil alternative","Jotai alternative","React hooks","derived state","reactive state","OIMDB","in-memory database","frontend orchestration","React best practices","type-safe React state","deterministic React","performance optimization","state synchronization","React state machine"]},i=void 0,c={},l=[{value:"Updating multiple collections in one run",id:"updating-multiple-collections-in-one-run",level:2},{value:"Flux comparison (why this is better)",id:"flux-comparison-why-this-is-better",level:2},{value:"Example: Create Deck then Card (shared data)",id:"example-create-deck-then-card-shared-data",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"CNStra is an orchestration layer for state, replacing reducers, slices, thunks, and sagas with a typed neuron graph. OIMDB is a reactive in\u2011memory DB with indexed queries that is orders of magnitude faster than copying whole state trees on each change \u2014 but it requires a proper orchestrator. CNStra provides that orchestration."}),"\n",(0,a.jsx)(n.p,{children:"Why not Flux?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Flux-style reducers have unclear inter-reducer communication; coordinating dependent updates is awkward or expensive."}),"\n",(0,a.jsx)(n.li,{children:"Many state managers copy large trees to preserve immutability, which is slow and GC-heavy."}),"\n",(0,a.jsx)(n.li,{children:"There\u2019s no built-in, efficient \u201cafter everything settles, emit UI events\u201d mechanism."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Our approach:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A controlling neuron orchestrates the sequence of updates across models."}),"\n",(0,a.jsx)(n.li,{children:"OIMDB stores normalized data with reactive indexes (no tree copies)."}),"\n",(0,a.jsx)(n.li,{children:"After all model updates in a run, we flush the OIMDB event queue once, so the UI updates efficiently in batches."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Minimal setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { CNS, neuron, collateral } from '@cnstra/core';\nimport { OIMEventQueue, OIMEventQueueSchedulerMicrotask, OIMRICollection, OIMReactiveIndexManual } from '@oimdb/core';\n\nconst dbEventQueue = new OIMEventQueue({ scheduler: new OIMEventQueueSchedulerMicrotask() });\nexport const users = new OIMRICollection(dbEventQueue, {\n  indexes: { byId: new OIMReactiveIndexManual<string, string>(dbEventQueue) },\n  collectionOpts: { selectPk: (u: { id: string }) => u.id }\n});\n\n// Define UI/update collateral\nconst userUpdated = collateral<{ id: string; name: string }>('user:updated');\n\n// Controlling neuron updates models and returns nothing (end of branch)\nexport const usersNeuron = neuron('users', {}).dendrite({\n  collateral: userUpdated,\n  response: (payload) => {\n    users.collection.upsertOne({ id: payload.id, name: payload.name });\n    // more model updates...\n    // OIMDB event queue will flush after the run completes\n    return undefined;\n  },\n});\n\nconst cns = new CNS([usersNeuron]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"React usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useSelectEntityByPk } from '@oimdb/react';\n\nconst EMPTY: any[] = [];\n\nfunction UserName({ id }: { id: string }) {\n  const user = useSelectEntityByPk(users, id) || null;\n  return <span>{user?.name ?? ''}</span>;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Key points"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"CNStra: deterministic orchestration, explicit branching, cancellation."}),"\n",(0,a.jsx)(n.li,{children:"OIMDB: normalized, indexed, reactive store; no full-tree copies."}),"\n",(0,a.jsx)(n.li,{children:"Together: predictable flows and high performance UI updates with a single flush after model updates."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"updating-multiple-collections-in-one-run",children:"Updating multiple collections in one run"}),"\n",(0,a.jsx)(n.p,{children:"Best practice: each model is updated by its own domain neuron. The controller emits one controller\u2011owned signal with both payloads; each domain neuron listens and updates its model."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { collateral, neuron } from '@cnstra/core';\nimport { OIMEventQueue, OIMEventQueueSchedulerMicrotask, OIMRICollection, OIMReactiveIndexManual } from '@oimdb/core';\n\n// Event queue + collections\nconst dbEventQueue = new OIMEventQueue({ scheduler: new OIMEventQueueSchedulerMicrotask() });\nexport const users = new OIMRICollection(dbEventQueue, {\n  indexes: { byId: new OIMReactiveIndexManual<string, string>(dbEventQueue) },\n  collectionOpts: { selectPk: (u: { id: string }) => u.id },\n});\nexport const posts = new OIMRICollection(dbEventQueue, {\n  indexes: { byAuthor: new OIMReactiveIndexManual<string, string>(dbEventQueue) },\n  collectionOpts: { selectPk: (p: { id: string }) => p.id },\n});\n\n// Single incoming signal with both payloads\nconst userAndPostUpdated = collateral<{\n  user: { id: string; name: string };\n  post: { id: string; title: string; authorId: string };\n}>('user+post:updated');\n\n// Controller-owned single update signal\nconst controllerUpdated = collateral<{\n  user: { id: string; name: string };\n  post: { id: string; title: string; authorId: string };\n}>('controller:updated');\n\n// Controller receives inbound and emits one outbound\nexport const controller = neuron('controller', { controllerUpdated })\n  .dendrite({\n    collateral: userAndPostUpdated,\n    response: (payload, axon) => axon.controllerUpdated.createSignal(payload),\n  });\n\n// Domain neurons update their own collections\nexport const userModel = neuron('user-model', {}).dendrite({\n  collateral: controllerUpdated,\n  response: (p) => {\n    users.collection.upsertOne(p.user);\n    return undefined;\n  },\n});\n\nexport const postModel = neuron('post-model', {}).dendrite({\n  collateral: controllerUpdated,\n  response: (p) => {\n    posts.collection.upsertOne(p.post);\n    return undefined;\n  },\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"React selectors will observe a single batched change after the run completes, not N re-renders during the sequence."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useSelectEntityByPk, useSelectEntitiesByIndexKey } from '@oimdb/react';\n\nconst EMPTY: any[] = [];\n\nfunction AuthorWithPosts({ authorId }: { authorId: string }) {\n  const user = useSelectEntityByPk(users, authorId) || null;\n  const postsByAuthor = useSelectEntitiesByIndexKey(posts, 'byAuthor', authorId) || EMPTY;\n  return (\n    <section>\n      <h4>{user?.name}</h4>\n      <ul>{postsByAuthor.map(p => <li key={p.id}>{p.title}</li>)}</ul>\n    </section>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"flux-comparison-why-this-is-better",children:"Flux comparison (why this is better)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Multiple reducers/slices need to coordinate ordering and cross-updates; you either duplicate logic or invent ad\u2011hoc messaging between slices."}),"\n",(0,a.jsx)(n.li,{children:"Immutable tree copies cause extra allocations and GC pressure; updating two parts often triggers two renders."}),"\n",(0,a.jsx)(n.li,{children:"There\u2019s no first\u2011class \u201cafter everything settles\u201d phase; batching is fragile and framework\u2011specific."}),"\n",(0,a.jsx)(n.li,{children:"With CNStra + OIMDB: a controlling neuron dictates order deterministically; OIMDB writes are O(1) upserts into normalized tables; the event queue flushes once after the run, so the UI updates predictably and fast."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"example-create-deck-then-card-shared-data",children:"Example: Create Deck then Card (shared data)"}),"\n",(0,a.jsxs)(n.p,{children:["Goal: on UI click, create a deck first (to obtain ",(0,a.jsx)(n.code,{children:"deckId"}),"), then create a card that needs that ",(0,a.jsx)(n.code,{children:"deckId"}),". We orchestrate this with a controlling neuron; OIMDB persists models; the event queue flushes once after the run."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { CNS, collateral, neuron, withCtx } from '@cnstra/core';\nimport {\n  OIMEventQueue,\n  OIMEventQueueSchedulerMicrotask,\n  OIMRICollection,\n  OIMReactiveIndexManual,\n} from '@oimdb/core';\n\n// OIMDB setup\nconst dbEventQueue = new OIMEventQueue({ scheduler: new OIMEventQueueSchedulerMicrotask() });\nexport const decks = new OIMRICollection(dbEventQueue, {\n  indexes: { byId: new OIMReactiveIndexManual<string, string>(dbEventQueue) },\n  collectionOpts: { selectPk: (d: { id: string }) => d.id },\n});\nexport const cards = new OIMRICollection(dbEventQueue, {\n  indexes: { byDeck: new OIMReactiveIndexManual<string, string>(dbEventQueue) },\n  collectionOpts: { selectPk: (c: { id: string }) => c.id },\n});\n\n// Collaterals\nconst uiCreateCardClick = collateral<{ deckTitle: string; cardTitle: string }>('ui:createCardClick');\n\n// Controller owns these request collaterals (only controller emits them)\nconst controllerCreateDeck = collateral<{ title: string }>('controller:deck:create');\nconst controllerCreateCard = collateral<{ deckId: string; cardId: string; title: string }>('controller:card:create');\n\n// Deck owns its response collateral (only deck emits it)\nconst deckCreated = collateral<{ deckId: string; title: string }>('deck:created');\n\n// Services (mocked)\nconst deckService = { create: async (title: string) => 'deck-' + Math.random().toString(36).slice(2) };\nconst id = () => 'card-' + Math.random().toString(36).slice(2);\n\n// Deck neuron: listens controller:deck:create, emits deck:created, upserts OIMDB\nexport const deckNeuron = neuron('deck', { deckCreated }).dendrite({\n  collateral: controllerCreateDeck,\n  response: async (payload, axon) => {\n    const deckId = await deckService.create(payload.title);\n    decks.collection.upsertOne({ id: deckId, title: payload.title });\n    return axon.deckCreated.createSignal({ deckId, title: payload.title });\n  },\n});\n\n// Card neuron: listens controller:card:create, upserts OIMDB\nexport const cardNeuron = neuron('card', {}).dendrite({\n  collateral: controllerCreateCard,\n  response: async (payload) => {\n    cards.collection.upsertOne({ id: payload.cardId, deckId: payload.deckId, title: payload.title });\n    return undefined; // end\n  },\n});\n\n// Controller neuron: emits only its own collaterals (controller:*)\nexport const controller = withCtx<{ cardTitle?: string }>()\n  .neuron('controller', { controllerCreateDeck, controllerCreateCard })\n  .dendrite({\n    collateral: uiCreateCardClick,\n    response: (payload, axon, ctx) => {\n      ctx.set({ cardTitle: payload.cardTitle });\n      return axon.controllerCreateDeck.createSignal({ title: payload.deckTitle });\n    },\n  })\n  .dendrite({\n    collateral: deckCreated,\n    response: (payload, axon, ctx) => {\n      const title = ctx.get()?.cardTitle ?? 'New Card';\n      return axon.controllerCreateCard.createSignal({ deckId: payload.deckId, cardId: id(), title });\n    },\n  });\n\n// CNS\nconst cns = new CNS([controller, deckNeuron, cardNeuron]);\n\n// UI click starts the run; OIMDB event queue flushes once after both upserts\nawait cns.stimulate(uiCreateCardClick.createSignal({ deckTitle: 'Inbox', cardTitle: 'First task' }));\n"})}),"\n",(0,a.jsx)(n.p,{children:"Rule of ownership"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"A neuron emits only collaterals from its own axon."}),"\n",(0,a.jsx)(n.li,{children:"Other neurons subscribe to those collaterals via dendrites."}),"\n",(0,a.jsxs)(n.li,{children:["In this example, controller emits ",(0,a.jsx)(n.code,{children:"controller:*"})," requests; deck emits ",(0,a.jsx)(n.code,{children:"deck:created"}),"; card writes data on ",(0,a.jsx)(n.code,{children:"controller:card:create"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(6540);const a={},o=r.createContext(a);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);