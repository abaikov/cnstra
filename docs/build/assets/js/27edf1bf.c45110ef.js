"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[634],{8453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>c});var n=s(6540);const t={},o=n.createContext(t);function i(e){const r=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(o.Provider,{value:r},e.children)}},9221:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"core/core-overview","title":"Core Overview","description":"Graph-routed, type-safe orchestration for reactive apps \u2014 no global event bus.","source":"@site/core/overview.md","sourceDirName":"core","slug":"/core/overview","permalink":"/docs/core/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/core/overview.md","tags":[],"version":"current","lastUpdatedAt":1760122051000,"frontMatter":{"id":"core-overview","title":"Core Overview","sidebar_label":"Overview","slug":"/core/overview"},"sidebar":"docs","previous":{"title":"API","permalink":"/docs/core/api"},"next":{"title":"Quick Start","permalink":"/docs/core/quick-start"}}');var t=s(4848),o=s(8453);const i={id:"core-overview",title:"Core Overview",sidebar_label:"Overview",slug:"/core/overview"},c=void 0,a={},l=[{value:"Why CNStra",id:"why-cnstra",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Execution model: synchronous vs asynchronous",id:"execution-model-synchronous-vs-asynchronous",level:2}];function d(e){const r={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"Graph-routed, type-safe orchestration for reactive apps \u2014 no global event bus."}),"\n",(0,t.jsxs)(r.p,{children:["CNStra models your app as a typed neuron graph. You explicitly start a run with ",(0,t.jsx)(r.code,{children:"cns.stimulate(...)"}),"; CNStra then performs a deterministic, hop-bounded traversal from collateral \u2192 dendrite \u2192 returned signal."]}),"\n",(0,t.jsx)(r.h2,{id:"why-cnstra",children:"Why CNStra"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Zero dependencies"}),": No third-party packages. Works in browsers, Node.js, serverless, edge, React Native, embedded systems."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Simple implementation"}),": The core is a set of TypeScript types, factory methods that enforce type safety, and a straightforward queue-based graph traversal. No magic, no complex runtime."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Deterministic routing"}),': Signals follow an explicit neuron graph, not broadcast to whoever "happens to listen".']}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Readable flows"}),": Each step is local and typed; branches are explicit, so debugging feels like reading a storyboard."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Backpressure & concurrency gates"}),": Built-in per-stimulation and per-neuron concurrency limits."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Saga-like orchestration"}),": Multi-step reactions with retries/cancellation (AbortSignal) via explicit branches."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Deterministic routing"}),"\n",(0,t.jsx)(r.li,{children:"Readable flows with explicit branches"}),"\n",(0,t.jsx)(r.li,{children:"Backpressure & concurrency gates"}),"\n",(0,t.jsx)(r.li,{children:"Saga-like orchestration via explicit branches and abort"}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["See also: ",(0,t.jsx)(r.a,{href:"/docs/core/quick-start",children:"Quick Start"}),", ",(0,t.jsx)(r.a,{href:"/docs/core/api",children:"API"}),", ",(0,t.jsx)(r.a,{href:"/docs/core/stimulation-options",children:"Stimulation Options"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"execution-model-synchronous-vs-asynchronous",children:"Execution model: synchronous vs asynchronous"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["Dendrite ",(0,t.jsx)(r.code,{children:"response"})," may be synchronous or ",(0,t.jsx)(r.code,{children:"async"})," (returning a Promise of signal(s))."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"onResponse"})," (local) and global listeners may also be sync or async."]}),"\n",(0,t.jsx)(r.li,{children:"If all listeners are synchronous for a given response, CNStra does not introduce extra async steps."}),"\n",(0,t.jsx)(r.li,{children:"If any listener returns a Promise, CNStra waits for all listeners in parallel before proceeding to enqueue next subscribers for that response."}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"cns.stimulate(...)"})," returns a Promise that resolves when the run completes, and rejects if any listener throws or rejects."]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);