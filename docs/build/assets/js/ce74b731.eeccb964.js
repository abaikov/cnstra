"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[55],{3518:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"recipes/error-handling","title":"Error Handling & Retry Logic - Best Practices for State Machines","description":"Learn error handling and retry strategies for CNStra state machines. Implement exponential backoff, circuit breakers, error recovery with context, and monitoring for resilient orchestration.","source":"@site/recipes/error-handling.md","sourceDirName":"recipes","slug":"/recipes/error-handling","permalink":"/docs/recipes/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/recipes/error-handling.md","tags":[],"version":"current","lastUpdatedAt":1760122051000,"frontMatter":{"id":"error-handling","title":"Error Handling & Retry Logic - Best Practices for State Machines","sidebar_label":"Error Handling","slug":"/recipes/error-handling","description":"Learn error handling and retry strategies for CNStra state machines. Implement exponential backoff, circuit breakers, error recovery with context, and monitoring for resilient orchestration.","keywords":["error handling","retry logic","exponential backoff","circuit breaker","error recovery","fault tolerance","resilience patterns","retry strategies","failure handling","exception handling","error monitoring","graceful degradation","compensation","rollback","idempotency"]},"sidebar":"docs","previous":{"title":"Cancellation","permalink":"/docs/recipes/cancel"},"next":{"title":"Multiple Signals","permalink":"/docs/recipes/multiple-signals"}}');var s=n(4848),i=n(8453);const o={id:"error-handling",title:"Error Handling & Retry Logic - Best Practices for State Machines",sidebar_label:"Error Handling",slug:"/recipes/error-handling",description:"Learn error handling and retry strategies for CNStra state machines. Implement exponential backoff, circuit breakers, error recovery with context, and monitoring for resilient orchestration.",keywords:["error handling","retry logic","exponential backoff","circuit breaker","error recovery","fault tolerance","resilience patterns","retry strategies","failure handling","exception handling","error monitoring","graceful degradation","compensation","rollback","idempotency"]},a=void 0,l={},c=[{value:"Error delivery",id:"error-delivery",level:2},{value:"Error recovery with context",id:"error-recovery-with-context",level:2},{value:"Retry with backoff (self-loop)",id:"retry-with-backoff-self-loop",level:2},{value:"Tips",id:"tips",level:2},{value:"Global listeners",id:"global-listeners",level:3},{value:"Best practices",id:"best-practices",level:2}];function d(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.p,{children:["Handle errors gracefully using ",(0,s.jsx)(r.code,{children:"onResponse"})," callbacks (sync or async) and context-based retry."]}),"\n",(0,s.jsx)(r.h2,{id:"error-delivery",children:"Error delivery"}),"\n",(0,s.jsxs)(r.p,{children:["Errors are delivered immediately via ",(0,s.jsx)(r.code,{children:"onResponse"})," and also cause ",(0,s.jsx)(r.code,{children:"stimulate(...)"})," to reject if any response listener (local or global) throws or rejects:"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"await cns.stimulate(signal, {\n  onResponse: async (response) => {\n    if (response.error) {\n      await errorsRepo.store({\n        id: response.stimulationId,\n        signal: response.outputSignal?.collateralName || response.inputSignal?.collateralName,\n        error: String(response.error),\n      });\n      \n      if (response.error instanceof ValidationError) {\n        handleValidationError(response.error);\n      }\n    }\n  }\n});\n"})}),"\n",(0,s.jsxs)(r.p,{children:["If you do not await ",(0,s.jsx)(r.code,{children:"stimulate(...)"}),", the run still proceeds, but rejections from listeners won\u2019t be observed by the caller."]}),"\n",(0,s.jsx)(r.h2,{id:"error-recovery-with-context",children:"Error recovery with context"}),"\n",(0,s.jsx)(r.p,{children:"Save context for retry on failure:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"let savedContext: ICNSStimulationContextStore | undefined;\n\nawait cns.stimulate(signal, {\n  onResponse: (response) => {\n    if (response.error) {\n      savedContext = response.contextStore; // save for retry\n    }\n  }\n});\n\n// Retry with preserved context\nif (savedContext) {\n  await cns.stimulate(retrySignal, { ctx: savedContext });\n}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"retry-with-backoff-self-loop",children:"Retry with backoff (self-loop)"}),"\n",(0,s.jsx)(r.p,{children:"Use a self-looping neuron with context to track attempts and implement exponential backoff:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"import { withCtx, collateral } from '@cnstra/core';\n\nconst tryTask = collateral<{ taskId: string }>('task:try');\nconst completed = collateral<{ taskId: string }>('task:completed');\nconst failed = collateral<{ taskId: string; reason: string }>('task:failed');\n\nconst taskRunner = withCtx<{ attempt: number }>()\n  .neuron('task-runner', { tryTask, completed, failed })\n  .dendrite({\n    collateral: tryTask,\n    response: async (payload, axon, ctx) => {\n      const prev = ctx.get() ?? { attempt: 0 };\n      const attempt = prev.attempt + 1;\n      ctx.set({ attempt });\n\n      try {\n        await performTask(payload.taskId);\n        return axon.completed.createSignal({ taskId: payload.taskId });\n      } catch (err) {\n        if (attempt < 5) {\n          const backoff = Math.pow(2, attempt) * 100; // exponential backoff\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          return axon.tryTask.createSignal(payload); // self-loop retry\n        }\n        return axon.failed.createSignal({ taskId: payload.taskId, reason: String(err) });\n      }\n    },\n  });\n"})}),"\n",(0,s.jsx)(r.h2,{id:"tips",children:"Tips"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Use ",(0,s.jsx)(r.code,{children:"onResponse"})," for real-time error logging/monitoring; make it ",(0,s.jsx)(r.code,{children:"async"})," if you need to persist."]}),"\n",(0,s.jsx)(r.li,{children:"Store minimal retry state in context (attempt count, correlation IDs)."}),"\n",(0,s.jsx)(r.li,{children:"For long-lived sagas, persist context to a DB/OIMDB and re-stimulate on external triggers."}),"\n",(0,s.jsx)(r.li,{children:"Always set a max retry limit to avoid infinite loops."}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"global-listeners",children:"Global listeners"}),"\n",(0,s.jsxs)(r.p,{children:["Global listeners registered via ",(0,s.jsx)(r.code,{children:"addResponseListener"})," run for every stimulation alongside the local ",(0,s.jsx)(r.code,{children:"onResponse"}),". They also can be async; failures in any listener reject the ",(0,s.jsx)(r.code,{children:"stimulate(...)"})," Promise."]}),"\n",(0,s.jsx)(r.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Timeouts: wrap external I/O in timeouts inside dendrites and async ",(0,s.jsx)(r.code,{children:"onResponse"})," to avoid hanging runs."]}),"\n",(0,s.jsxs)(r.li,{children:["Idempotency: design ",(0,s.jsx)(r.code,{children:"onResponse"})," persistence to be idempotent (e.g., upserts, unique keys) so retries are safe."]}),"\n",(0,s.jsx)(r.li,{children:"Retry policy: prefer bounded retries with exponential backoff; use context to track attempts; avoid hot loops."}),"\n",(0,s.jsx)(r.li,{children:"Partial failure: emit explicit failure signals from dendrites when business errors occur; reserve thrown errors for exceptional cases."}),"\n",(0,s.jsxs)(r.li,{children:["Observability: tag ",(0,s.jsx)(r.code,{children:"stimulationId"})," and collateral names in logs/metrics; capture queueLength to identify bottlenecks."]}),"\n",(0,s.jsxs)(r.li,{children:["Isolation: keep ",(0,s.jsx)(r.code,{children:"onResponse"})," lightweight; move heavy processing to dedicated neurons/signals when possible."]}),"\n",(0,s.jsxs)(r.li,{children:["Concurrency: if persisting from ",(0,s.jsx)(r.code,{children:"onResponse"}),", consider batching or a queue to smooth spikes in traffic."]}),"\n",(0,s.jsxs)(r.li,{children:["Ordering: if ordering matters, include sequence numbers in payloads or serialize writes per ",(0,s.jsx)(r.code,{children:"stimulationId"}),"."]}),"\n",(0,s.jsx)(r.li,{children:"Durability: when persisting context for retries, write before emitting downstream effects; verify on restart."}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var t=n(6540);const s={},i=t.createContext(s);function o(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);