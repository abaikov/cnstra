"use strict";(self.webpackChunkcnstra_docs=self.webpackChunkcnstra_docs||[]).push([[779],{842:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"recipes/saga","title":"Saga Pattern Implementation with CNStra - Long-Running Workflows","description":"Implement saga pattern with CNStra for long-running, distributed workflows. Learn short-lived vs long-lived sagas, compensation logic, error handling, and external event triggers for Node.js backends and microservices.","source":"@site/recipes/saga.md","sourceDirName":"recipes","slug":"/recipes/saga","permalink":"/docs/recipes/saga","draft":false,"unlisted":false,"editUrl":"https://github.com/abaikov/cnstra/edit/master/docs/recipes/saga.md","tags":[],"version":"current","lastUpdatedAt":1759841036000,"frontMatter":{"id":"saga","title":"Saga Pattern Implementation with CNStra - Long-Running Workflows","sidebar_label":"Saga","slug":"/recipes/saga","description":"Implement saga pattern with CNStra for long-running, distributed workflows. Learn short-lived vs long-lived sagas, compensation logic, error handling, and external event triggers for Node.js backends and microservices.","keywords":["saga pattern","saga orchestration","distributed saga","compensation logic","long-running workflows","distributed transactions","microservices saga","event-driven saga","workflow coordination","process manager","choreography vs orchestration","eventual consistency","rollback logic","error recovery","event sourcing saga"]},"sidebar":"docs","previous":{"title":"Retries","permalink":"/docs/recipes/retry"},"next":{"title":"Self-loops","permalink":"/docs/recipes/self-loop-cycles"}}');var t=r(4848),o=r(8453);const i={id:"saga",title:"Saga Pattern Implementation with CNStra - Long-Running Workflows",sidebar_label:"Saga",slug:"/recipes/saga",description:"Implement saga pattern with CNStra for long-running, distributed workflows. Learn short-lived vs long-lived sagas, compensation logic, error handling, and external event triggers for Node.js backends and microservices.",keywords:["saga pattern","saga orchestration","distributed saga","compensation logic","long-running workflows","distributed transactions","microservices saga","event-driven saga","workflow coordination","process manager","choreography vs orchestration","eventual consistency","rollback logic","error recovery","event sourcing saga"]},s=void 0,c={},l=[];function d(e){const n={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Model long-running, multi-step reactions with explicit branches and cancel hooks."}),"\n",(0,t.jsx)(n.p,{children:"Short\u2011lived saga (single stimulation)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Entire flow completes within one ",(0,t.jsx)(n.code,{children:"stimulate(...)"})," run."]}),"\n",(0,t.jsx)(n.li,{children:"Each neuron emits only its own axon collaterals (signal ownership)."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { CNS, collateral, neuron } from '@cnstra/core';\n\n// Domain collaterals\nconst order = {\n  created: collateral<{ id: string }>('order:created'),\n  reserved: collateral<{ id: string }>('order:reserved'),\n  charged: collateral<{ id: string }>('order:charged'),\n  confirmed: collateral<{ id: string }>('order:confirmed'),\n  failed: collateral<{ id: string; reason?: string }>('order:failed'),\n  compensated: collateral<{ id: string }>('order:compensated'),\n};\n\n// Reserve inventory \u2192 emits reserved/failed (owned by reservation)\nexport const reservation = neuron('reservation', {\n  reserved: order.reserved,\n  failed: order.failed,\n}).dendrite({\n  collateral: order.created,\n  response: async (p, axon) => {\n    const ok = await inventory.reserve(p.id);\n    return ok\n      ? axon.reserved.createSignal({ id: p.id })\n      : axon.failed.createSignal({ id: p.id, reason: 'no_stock' });\n  },\n});\n\n// Charge payment \u2192 emits charged/failed; also compensates on failure (releases stock)\nexport const payment = neuron('payment', {\n  charged: order.charged,\n  failed: order.failed,\n  compensated: order.compensated,\n})\n  .dendrite({\n    collateral: order.reserved,\n    response: async (p, axon) => {\n      const ok = await payments.charge(p.id);\n      return ok\n        ? axon.charged.createSignal({ id: p.id })\n        : axon.failed.createSignal({ id: p.id, reason: 'card_declined' });\n    },\n  })\n  .dendrite({\n    collateral: order.failed,\n    response: async (p, axon) => {\n      await inventory.release(p.id);\n      return axon.compensated.createSignal({ id: p.id });\n    },\n  });\n\n// Confirm order \u2192 emits confirmed\nexport const confirmation = neuron('confirmation', {\n  confirmed: order.confirmed,\n}).dendrite({\n  collateral: order.charged,\n  response: (p, axon) => axon.confirmed.createSignal({ id: p.id }),\n});\n\n// Wire and run\nconst cns = new CNS([reservation, payment, confirmation]);\nawait cns.stimulate(order.created.createSignal({ id: 'o1' }));\n"})}),"\n",(0,t.jsx)(n.p,{children:"Long\u2011lived saga (multiple stimulations over time)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Re\u2011stimulate when an external event arrives (queue/webhook/cron/socket)."}),"\n",(0,t.jsx)(n.li,{children:"Use a small bridge neuron to map external events into domain collaterals (ownership preserved)."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const paymentReceivedExternal = collateral<{ id: string }>('ext:payment-received');\n\n// Bridge: converts external event into domain \"charged\" (owned by this bridge)\nexport const paymentBridge = neuron('payment-bridge', { charged: order.charged })\n  .dendrite({\n    collateral: paymentReceivedExternal,\n    response: (p, axon) => axon.charged.createSignal({ id: p.id }),\n  });\n\nconst cns = new CNS([reservation, payment, confirmation, paymentBridge]);\n\n// First run\nawait cns.stimulate(order.created.createSignal({ id: 'o1' }));\n\n// Later, on external event\nqueue.on('payment_received', async (m) => {\n  await cns.stimulate(paymentReceivedExternal.createSignal({ id: m.orderId }));\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["No function-passing neurons: use ",(0,t.jsx)(n.code,{children:"neuron(name, axon).dendrite({ collateral, response })"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Ownership: a neuron may emit only its axon collaterals; other neurons listen via dendrites."}),"\n",(0,t.jsxs)(n.li,{children:["Compensation is modeled as explicit branches; cancellation via ",(0,t.jsx)(n.code,{children:"AbortSignal"})," if needed."]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var a=r(6540);const t={},o=a.createContext(t);function i(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);